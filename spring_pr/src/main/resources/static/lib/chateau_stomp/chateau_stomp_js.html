<dom-module id="chateau-stomp-js">
    <script>
        Polymer({
            is: 'chateau-stomp-js',

            properties: {
                send_message_function: {
                    type: Object,
                    notify: true
                },
                // WebSocket connection to the server.
                _socket: {
                    type: Object
                },
                /** Map, where the key is a destination and value is an object that has the following fields:
                 * currentChannel - ID of the current channel. Possible values are: 0, 1;
                 * firstChannel - an object with data of the first channel
                 * secondChannel - an object with data of the second channel
                 * An object with data of a channel has the following fields:
                 * waitingList - a list of messages that are waiting to be confirmed by the server
                 * lastMessageID - ID of the last message that has been sent to the server
                 * */
                _sent_messages: {
                    type: Object
                }
            },
            /** Name of JSON parameter that is a destination. */
            DESTINATION_PARAM_NAME: "destination",
            /** Name of JSON parameter that is a channel index. */
            CHANNEL_PARAM_NAME: "channel",
            /** Name of JSON parameter that is a message ID. */
            MESSAGEID_PARAM_NAME: "id",
            /** Name of JSON parameter that is a frame name. */
            FRAME_PARAM_NAME: "frame",
            /** Name of a frame that is to confirm a message has been received. */
            ACK_FRAME_NAME: "ACK",
            /** Name of a frame that commands to clean a channel. */
            CLEAN_FRAME_NAME: "CLEAN",
            /** Name of a frame that tells that the cleaning operation has completed successfully. */
            CLEANED_FRAME_NAME: "CLEANED",

            ready: function () {
                console.log("chateau-stomp-js is ready.");
                this._connect(null, null);
                var element = this;
                //Sends a message to a group of users.
                this.send_message_function = function (messagemap) {
                    return element.send_message_to_destination("group-chat", messagemap);
                };
                this._sent_messages = {};
            },
            /**
             * Connects to the server.
             * @param e
             * @param detail
             * @private
             */
            _connect: function (e, detail) {
                console.log("connecting to stomp...");
                this._socket = new WebSocket('ws://localhost:8080/hello/');
                var element = this;
                this._socket.onopen = function () {
                    console.log('Opened a WebSocket connection.');
                };
                this._socket.onmessage = function (message) {
                    console.log("The client got the following message: " + message.data);
                    var messageMap = JSON.parse(message.data);
                    // get destination from the message
                    var destination = messageMap[element.DESTINATION_PARAM_NAME];
                    if (destination == null || destination == '') {
                        console.log("Server sent a message without a destination.");
                        return;
                    }
                    // Cleaning the map.
                    messageMap[element.DESTINATION_PARAM_NAME] = null;
                    // get a channel from the message
                    var channel = messageMap[element.CHANNEL_PARAM_NAME];
                    if (channel == null || channel == '') {
                        channel = 0;
                    }
                    messageMap[element.CHANNEL_PARAM_NAME] = null;
                    var messageID = messageMap[element.MESSAGEID_PARAM_NAME];
                    if (messageID == null || messageID == '') {
                        messageID = 0;
                    }
                    messageMap[element.MESSAGEID_PARAM_NAME] = null;
                    // get a frame name
                    var frame = messageMap[element.FRAME_PARAM_NAME];
                    if (frame == null || frame == '') {
                        console.log("Server sent a message without a frame name.");
                        return;
                    }
                    messageMap[element.FRAME_PARAM_NAME] = null;
                    if (frame == element.ACK_FRAME_NAME) {
                        console.log('The client got an acknowledgement about the message: ' + message);
                        // get a destination object
                        var destinationObj = element._sent_messages[destination];
                        if (destinationObj == null) {
                            console.log('Server sent a message with unknown destination. The destination is ' + destination);
                            return;
                        }
                        // get the channel object
                        var channelObj = channel == 0 ? destinationObj.firstChannel : destinationObj.secondChannel;
                        var waitingMessageData = null;
                        var indexFound = null;
                        for (index = 0; index < channelObj.waitingList.length; ++index) {
                            var messageData = channelObj.waitingList[index];
                            if (messageID == messageData.messageID) {
                                waitingMessageData = messageData;
                                indexFound = index;
                                break;
                            }
                        }
                        if (waitingMessageData == null) {
                            console.log('The client does not want to know about message number ' + messageID);
                        } else {
                            channelObj.waitingList.splice(indexFound, 1); //remove a message to the queue
                            waitingMessageData.onAck(messageMap);
                            // index of the other channel
                            var otherChannel = channel == 0 ? 1 : 0;
                            var otherChannelObj = otherChannel == 0 ?
                                    destinationObj.firstChannel :
                                    destinationObj.secondChannel;
                            // if the other channel is fresh.
                            if (otherChannelObj.lastMessageID == -1) {
                                // Switching to the other channel.
                                console.log("Switching to the other channel.");
                                destinationObj.currentChannel = otherChannel;
                            }
                            console.log("destinationObj.currentChannel='" + destinationObj.currentChannel +
                                    "', channel='" + channel + "', " + channelObj.waitingList.length);
                            //if the other channel already active and the current channel's waiting list is empty.
                            if (channel != destinationObj.currentChannel && channelObj.waitingList.length == 0) {
                                console.log('cleaning this channel.');
                                element._request_channel_clean(destination, channel);
                            }
                            // clean the other channel if necessary
                            if (otherChannelObj.waitingList.length == 0 && otherChannelObj.lastMessageID > -1) {
                                console.log('cleaning the other channel.');
                                element._request_channel_clean(destination, otherChannel);
                            }
                        }
                    } else {
                        console.log('Unsupported frame type.');
                    }
                };
            },
            _request_channel_clean: function (destination, channelIndex) {
                var element = this;
                // get the channel object
                var destinationObj = this._sent_messages[destination];
                var channelObj = channelIndex == 0 ? destinationObj.firstChannel : destinationObj.secondChannel;
                if (channelObj.cleaning == null || channelObj.cleaning == false) {
                    channelObj.cleaning = true;
                    var sendCleanFunction = function () {
                        console.log("cleaning a channel.");
                        var cleanFrameMap = {};
                        cleanFrameMap[element.FRAME_PARAM_NAME] = element.CLEAN_FRAME_NAME;
                        cleanFrameMap[element.DESTINATION_PARAM_NAME] = destination;
                        cleanFrameMap[element.CHANNEL_PARAM_NAME] = channelIndex;
                        //sending the frame
                        element._socket.send(JSON.stringify(cleanFrameMap));
                        if (channelObj.cleaning == true) {
                            setTimeout(sendCleanFunction, 5000);
                        }
                    };
                    sendCleanFunction();
                }
            },
            /**
             * Sends a message to a specific destination. The function does not know anything about message delivery
             * strategy. After the message is sent, the [message] map contains the channel number and message number.
             * @param destination string with a destination
             * @param message map with a message
             */
            send_message_to_destination: function (destination, message) {
                // Get the current channel if it is present in the map. Set the current channel to 0 if it is absent.
                var destinationObj = this._sent_messages[destination];
                console.log("destinationObj: " + destinationObj);
                if (destinationObj == null) {
                    destinationObj = this._create_new_destination_object();
                    this._sent_messages[destination] = destinationObj;
                }
                var element = this;
                message[this.CHANNEL_PARAM_NAME] = destinationObj.currentChannel;
                var channelObj = destinationObj.currentChannel == 0 ?
                        destinationObj.firstChannel :
                        destinationObj.secondChannel;
                channelObj.lastMessageID++;
                message[this.DESTINATION_PARAM_NAME] = destination;
                message[this.MESSAGEID_PARAM_NAME] = channelObj.lastMessageID;
                // Adding a message map to the register only after all fields are filled.
                var waitingMessageData = {};
                waitingMessageData.messageID = channelObj.lastMessageID;
                waitingMessageData.sentMessage = message;
                waitingMessageData.onAck = function (messageMap) {
                    console.log("Message ack received.");
                };
                channelObj.waitingList.push(waitingMessageData);
                element._socket.send(JSON.stringify(message));
                return waitingMessageData;
            },
            /**
             * Creates an instance of an object that has data about 1 channel of messages.
             */
            _create_new_destination_object: function () {
                var destinationObj = {};
                destinationObj.firstChannel = {};
                destinationObj.secondChannel = {};
                destinationObj.firstChannel.waitingList = [];
                destinationObj.firstChannel.lastMessageID = -1;
                destinationObj.secondChannel.waitingList = [];
                destinationObj.secondChannel.lastMessageID = -1;
                destinationObj.currentChannel = 0; //first channel
                return destinationObj;
            }
        });
    </script>
    <script src="sockjs-1.1.1.js"></script>
    <script src="stomp.js"></script>
</dom-module>
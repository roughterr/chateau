<dom-module id="chateau-stomp-js">
    <script>
        Polymer({
            is: 'chateau-stomp-js',

            properties: {
                send_message_function: {
                    type: Object,
                    notify: true
                },
                // WebSocket connection to the server.
                _socket: {
                    type: Object
                },
                /** Map, where the key is a destination and value is an object that has the following fields:
                 * currentChannel - ID of the current channel. Possible values are: 0, 1;
                 * firstChannel - an object with data of the first channel
                 * secondChannel - an object with data of the second channel
                 * An object with data of a channel has the following fields:
                 * waitingMap - a map of messages that are waiting to be confirmed by the server
                 * lastMessageID - ID of the last message that has been sent to the server
                 * */
                _sent_messages: {
                    type: Object
                }
            },
            /** Name of JSON parameter that is a destination. */
            DESTINATION_PARAM_NAME: "destination",
            /** Name of JSON parameter that is a channel index. */
            CHANNEL_PARAM_NAME: "channel",
            /** Name of JSON parameter that is a message ID. */
            MESSAGEID_PARAM_NAME: "id",
            /** Name of JSON parameter that is a frame name. */
            FRAME_PARAM_NAME: "frame",
            /** Name of a frame that is to confirm a message has been received. */
            ACK_FRAME_NAME: "ACK",

            ready: function () {
                console.log("chateau-stomp-js is ready.");
                this._connect(null, null);
                var element = this;
                //Sends a message to a group of users.
                this.send_message_function = function (messagemap) {
                    return element.send_message_to_destination("group-chat", messagemap);
                };
                this._sent_messages = {};
            },
            /**
             * Connects to the server.
             * @param e
             * @param detail
             * @private
             */
            _connect: function (e, detail) {
                console.log("connecting to stomp...");
                this._socket = new WebSocket('ws://localhost:8080/hello/');
                var element = this;
                this._socket.onopen = function () {
                    console.log('Opened a WebSocket connection.');
                };
                this._socket.onmessage = function (message) {
                    console.log("The client got the following message: " + message.data);
                    var messageMap = JSON.parse(message.data);
                    // get destination from the message
                    var destination = messageMap[element.DESTINATION_PARAM_NAME];
                    if (destination == null || destination == '') {
                        console.log("Server sent a message without a destination.");
                        return;
                    }
                    // Cleaning the map.
                    messageMap[element.DESTINATION_PARAM_NAME] = null;
                    // get a channel from the message
                    var channel = messageMap[element.CHANNEL_PARAM_NAME];
                    if (channel == null || channel == '') {
                        channel = 0;
                    }
                    messageMap[element.CHANNEL_PARAM_NAME] = null;
                    var messageID = messageMap[element.MESSAGEID_PARAM_NAME];
                    if (messageID == null || messageID == '') {
                        messageID = 0;
                    }
                    messageMap[element.MESSAGEID_PARAM_NAME] = null;
                    // get a frame name
                    var frame = messageMap[element.FRAME_PARAM_NAME];
                    if (frame == null || frame == '') {
                        console.log("Server sent a message without a frame name.");
                        return;
                    }
                    messageMap[element.FRAME_PARAM_NAME] = null;
                    if (frame == element.ACK_FRAME_NAME) {
                        console.log('The client got an acknowledgement about the message: ' + message);
                        // get a destination object
                        var destinationObj = element._sent_messages[destination];
                        if (destinationObj == null) {
                            console.log('Server sent a message with unknown destination. The destination is ' + destination);
                            return;
                        }
                        // get the channel object
                        var channelObj = channel == 0 ? destinationObj.firstChannel : destinationObj.secondChannel;
                        var waitingMessageData = channelObj.waitingMap[messageID];
                        if (waitingMessageData == null) {
                            console.log('The client does not want to know about message number ' + messageID);
                        } else {
                            waitingMessageData.onAck(messageMap);
                        }
                    } else {
                        console.log('Unsupported frame type.');
                    }
                };
//                this._stompClient = Stomp.over(socket);
//                var element = this;
//                this._stompClient.connect('ian', "ian", function (frame) {
//                    //setConnected(true);
//                    console.log('Connected: ' + frame);
//                    element._stompClient.subscribe('/user/message2group', function (messageFromServer) {
//                        console.log('/user/message2group got.');
//                        var response = JSON.parse(messageFromServer.body);
//                        element._sent_messages[response.messageClientID].markAsRead();
//                    });
//                    element._stompClient.subscribe('/user/message2group-news', function (messageFromServer) {
//                        console.log('/user/message2group-news got.');
//                        element.got_message_function(JSON.parse(messageFromServer.body));
//                    });
//                });
            },
            /**
             * Sends a message to a specific destination. The function does not know anything about message delivery
             * strategy. After the message is sent, the [message] map contains the channel number and message number.
             * @param destination string with a destination
             * @param message map with a message
             */
            send_message_to_destination: function (destination, message) {
                // Get the current channel if it is present in the map. Set the current channel to 0 if it is absent.
                var destinationObj = this._sent_messages[destination];
                console.log("destinationObj: " + destinationObj);
                if (destinationObj == null) {
                    destinationObj = this._create_new_destination_object();
                    this._sent_messages[destination] = destinationObj;
                }
                var element = this;
                message[this.CHANNEL_PARAM_NAME] = destinationObj.currentChannel;
                var channelObj = destinationObj.currentChannel == 0 ?
                        destinationObj.firstChannel :
                        destinationObj.secondChannel;
                channelObj.lastMessageID++;
                message[this.DESTINATION_PARAM_NAME] = destination;
                message[this.MESSAGEID_PARAM_NAME] = channelObj.lastMessageID;
                // Adding a message map to the register only after all fields are filled.
                var waitingMessageData = {};
                waitingMessageData.sentMessage = message;
                waitingMessageData.onAck = function (messageMap) {
                    console.log("Message ack received.");
                };
                channelObj.waitingMap[channelObj.lastMessageID] = waitingMessageData;
                element._socket.send(JSON.stringify(message));
                return waitingMessageData;
            },
            /**
             * Creates an instance of an object that has data about 1 channel of messages.
             */
            _create_new_destination_object: function () {
                var destinationObj = {};
                destinationObj.firstChannel = {};
                destinationObj.secondChannel = {};
                destinationObj.firstChannel.waitingMap = {};
                destinationObj.firstChannel.lastMessageID = -1;
                destinationObj.secondChannel.waitingMap = {};
                destinationObj.secondChannel.lastMessageID = -1;
                destinationObj.currentChannel = 0; //first channel
                return destinationObj;
            }
        });
    </script>
    <script src="sockjs-1.1.1.js"></script>
    <script src="stomp.js"></script>
</dom-module>